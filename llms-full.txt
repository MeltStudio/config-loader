# @meltstudio/config-loader

> A type-safe configuration loader for Node.js — YAML, JSON, .env, environment variables, and CLI arguments.

This file contains all documentation content in a single document following the llmstxt.org standard.

## @meltstudio/config-loader


A type-safe configuration loader for Node.js. Define your schema once, load from YAML or JSON files, `.env` files, environment variables, and CLI arguments — and get a fully typed result with zero manual type annotations.

> **Upgrading from v1?** v1.x is deprecated. v2 includes breaking changes to the public API, object schema syntax, and requires Node.js >= 20. Install the latest version with `npm install @meltstudio/config-loader@latest` or `yarn add @meltstudio/config-loader@latest`.

## Why config-loader?

Most config libraries give you `Record<string, unknown>` and leave you to cast or validate manually. config-loader infers TypeScript types directly from your schema definition:

```typescript
import c from "@meltstudio/config-loader";

const config = c
  .schema({
    port: c.number({ required: true, env: "PORT" }),
    database: c.object({
      item: {
        host: c.string({ required: true }),
        credentials: c.object({
          item: {
            username: c.string(),
            password: c.string({ env: "DB_PASSWORD" }),
          },
        }),
      },
    }),
    features: c.array({
      required: true,
      item: c.object({
        item: {
          name: c.string(),
          enabled: c.bool(),
        },
      }),
    }),
  })
  .load({
    env: true,
    args: true,
    files: "./config.yaml",
  });

// config is fully typed:
// {
//   port: number;
//   database: { host: string; credentials: { username: string; password: string } };
//   features: { name: string; enabled: boolean }[];
// }
```

No separate interface to maintain. No `as` casts. The types flow from the schema.

## Features

- **Full type inference** — schema definition produces typed output automatically
- **Multiple sources** — YAML files, JSON files, `.env` files, environment variables, CLI arguments
- **Priority resolution** — CLI > process.env > `.env` files > Config files > Defaults
- **`.env` file support** — load environment variables from `.env` files with automatic line tracking
- **Nested objects and arrays** — deeply nested configs with full type safety
- **Structured errors** — typed `ConfigLoadError` with per-field error details and warnings
- **Enum constraints** — restrict values to a fixed set with `oneOf`, with full type narrowing
- **Schema validation** — optional per-field validation via [Standard Schema](https://github.com/standard-schema/standard-schema) (Zod, Valibot, ArkType, or custom)
- **Strict mode** — promote warnings to errors for production safety
- **Default values** — static or computed (via functions)
- **Multiple files / directory loading** — load from a list of files or an entire directory

## Requirements

- Node.js >= 20

## Installation

```bash
npm install @meltstudio/config-loader
```

```bash
yarn add @meltstudio/config-loader
```

## Quick Start

**config.yaml:**

```yaml
version: 1.0.0
website:
  title: My Website
  description: A simple and elegant website
  isProduction: false

database:
  host: localhost
  port: 5432
  credentials:
    username: admin
    password: secret

socialMedia: [https://twitter.com/example, https://instagram.com/example]

features:
  - name: Store
    enabled: true
  - name: Admin
    enabled: false
```

**index.ts:**

```typescript
import path from "path";
import c from "@meltstudio/config-loader";

const config = c
  .schema({
    version: c.string({ required: true, cli: true }),
    website: c.object({
      item: {
        title: c.string({ required: true }),
        url: c.string({
          required: false,
          defaultValue: "www.mywebsite.dev",
        }),
        description: c.string({ required: true }),
        isProduction: c.bool({ required: true }),
      },
    }),
    database: c.object({
      item: {
        host: c.string({ required: true }),
        port: c.number({ required: true }),
        credentials: c.object({
          item: {
            username: c.string(),
            password: c.string(),
          },
        }),
      },
    }),
    socialMedia: c.array({
      required: true,
      item: c.string({ required: true }),
    }),
    features: c.array({
      required: true,
      item: c.object({
        item: {
          name: c.string(),
          enabled: c.bool(),
        },
      }),
    }),
  })
  .load({
    env: false,
    args: true,
    files: path.join(__dirname, "./config.yaml"),
  });

console.log(JSON.stringify(config, null, 2));
```

Output:

```json
{
  "version": "1.0.0",
  "website": {
    "title": "My Website",
    "url": "www.mywebsite.dev",
    "description": "A simple and elegant website",
    "isProduction": false
  },
  "database": {
    "host": "localhost",
    "port": 5432,
    "credentials": {
      "username": "admin",
      "password": "secret"
    }
  },
  "socialMedia": [
    "https://twitter.com/example",
    "https://instagram.com/example"
  ],
  "features": [
    { "name": "Store", "enabled": true },
    { "name": "Admin", "enabled": false }
  ]
}
```

## Schema API

### Primitives

```typescript
c.string({
  required: true,
  env: "MY_VAR",
  cli: true,
  defaultValue: "fallback",
});
c.number({ required: true, env: "PORT" });
c.bool({ env: "DEBUG", defaultValue: false });
```

### Objects

Use `c.object()` to declare nested object schemas:

```typescript
c.object({
  item: {
    host: c.string(),
    port: c.number(),
  },
});
```

Objects can be nested arbitrarily deep:

```typescript
c.schema({
  database: c.object({
    item: {
      host: c.string(),
      port: c.number(),
      credentials: c.object({
        item: {
          username: c.string(),
          password: c.string({ env: "DB_PASSWORD" }),
        },
      }),
    },
  }),
});
```

`c.object()` accepts a `required` option (defaults to `false`). When the entire subtree is absent from all sources, child `required` options will trigger errors through normal validation.

### Arrays

```typescript
c.array({ required: true, item: c.string() }); // string[]
c.array({ required: true, item: c.number() }); // number[]
c.array({
  item: c.object({
    item: { name: c.string(), age: c.number() },
  }),
}); // { name: string; age: number }[]
```

## Enum Constraints (`oneOf`)

Use `oneOf` to restrict a field to a fixed set of allowed values. The check runs after type coercion and before any `validate` schema:

```typescript
const config = c
  .schema({
    env: c.string({
      env: "NODE_ENV",
      defaultValue: "development",
      oneOf: ["development", "staging", "production"],
    }),
    logLevel: c.number({
      env: "LOG_LEVEL",
      defaultValue: 1,
      oneOf: [0, 1, 2, 3],
    }),
  })
  .load({ env: true, args: false });
```

If a value is not in the allowed set, a `ConfigLoadError` is thrown with `kind: "validation"`.

### Type Narrowing

When `oneOf` is provided, the inferred type is automatically narrowed to the union of the allowed values:

```typescript
const config = c
  .schema({
    env: c.string({ oneOf: ["dev", "staging", "prod"] }),
  })
  .load({ env: false, args: false });

// config.env is typed as "dev" | "staging" | "prod", not string
```

When used with `cli: true`, the `--help` output automatically lists the allowed values.

## Validation

Add per-field validation using the `validate` option. config-loader accepts any [Standard Schema v1](https://github.com/standard-schema/standard-schema) implementation — including **Zod**, **Valibot**, and **ArkType** — or a custom validator.

Validation runs **after** type coercion, so validators see the final typed value (e.g., the number `3000`, not the string `"3000"` from an env var).

### With Zod

```typescript
import c from "@meltstudio/config-loader";
import { z } from "zod";

const config = c
  .schema({
    port: c.number({
      required: true,
      env: "PORT",
      validate: z.number().min(1).max(65535),
    }),
    host: c.string({
      required: true,
      validate: z.string().url(),
    }),
    env: c.string({
      defaultValue: "development",
      validate: z.enum(["development", "staging", "production"]),
    }),
  })
  .load({ env: true, args: false, files: "./config.yaml" });
```

### With a custom validator

Any object with a `~standard.validate()` method works:

```typescript
const portValidator = {
  "~standard": {
    version: 1,
    vendor: "my-app",
    validate(value: unknown) {
      if (typeof value === "number" && value >= 1 && value <= 65535) {
        return { value };
      }
      return { issues: [{ message: "must be a valid port (1-65535)" }] };
    },
  },
};

c.number({ required: true, env: "PORT", validate: portValidator });
```

Validation errors are collected alongside other config errors and thrown as `ConfigLoadError` with `kind: "validation"`:

```typescript
try {
  const config = c.schema({ ... }).load({ ... });
} catch (err) {
  if (err instanceof ConfigLoadError) {
    for (const entry of err.errors) {
      if (entry.kind === "validation") {
        console.error(`Validation: ${entry.path} — ${entry.message}`);
      }
    }
  }
}
```

## Loading Sources

```typescript
.load({
  env: true,          // Read from process.env
  args: true,         // Read from CLI arguments (--database.port 3000)
  files: "./config.yaml",                    // Single YAML file
  files: "./config.json",                    // Single JSON file
  files: ["./base.yaml", "./overrides.json"], // Mix YAML and JSON (first takes priority)
  dir: "./config.d/",                        // All files in a directory (sorted)
  envFile: "./.env",                         // Single .env file
  envFile: ["./.env", "./.env.local"],       // Multiple .env files (later overrides earlier)
  defaults: { port: 3000 },                  // Programmatic defaults
})
```

Both YAML (`.yaml`, `.yml`) and JSON (`.json`) files are supported. The format is detected automatically from the file extension.

**Priority order:** CLI arguments > `process.env` > `.env` files > Config files > Defaults

## Extended Loading (Source Metadata)

Use `loadExtended()` instead of `load()` to get each value wrapped in a `ConfigNode` that includes source metadata — where the value came from, which file, environment variable, or CLI argument provided it.

```typescript
import c from "@meltstudio/config-loader";

const { data, warnings } = c
  .schema({
    port: c.number({ required: true, env: "PORT" }),
    host: c.string({ defaultValue: "localhost" }),
  })
  .loadExtended({
    env: true,
    args: false,
    files: "./config.yaml",
  });

// `warnings` is a string[] of non-fatal issues (e.g. type coercions, unused env mappings)
if (warnings.length > 0) {
  warnings.forEach((w) => console.warn(w));
}

// Each leaf in `data` is a ConfigNode with:
// {
//   value: 3000,
//   path: "port",
//   sourceType: "env" | "envFile" | "file" | "args" | "default",
//   file: "./config.yaml" | "./.env" | null,
//   variableName: "PORT" | null,
//   argName: null,
//   line: 5 | null,      // source line (1-based) for YAML, JSON, and .env files; null for env/args/default
//   column: 3 | null      // source column (1-based) for YAML, JSON, and .env files; null for env/args/default
// }
console.log(data.port.value); // 3000
console.log(data.port.sourceType); // "env"
console.log(data.port.variableName); // "PORT"
```

This is useful for debugging configuration resolution, building admin UIs that show where each setting originated, or auditing which sources are active.

### Debug Helper

Use `printConfig()` to format the result of `loadExtended()` as a readable table:

```typescript
import c, { printConfig } from "@meltstudio/config-loader";

const result = c
  .schema({
    host: c.string({ defaultValue: "localhost" }),
    port: c.number({ env: "PORT" }),
    debug: c.bool({ cli: true }),
  })
  .loadExtended({ env: true, args: true, files: "./config.yaml" });

printConfig(result);
```

Output:

```
┌───────┬───────────┬─────────┬────────────────┐
│ Path  │ Value     │ Source  │ Detail         │
├───────┼───────────┼─────────┼────────────────┤
│ host  │ localhost │ default │                │
│ port  │ 8080      │ env     │ PORT           │
│ debug │ true      │ args    │ --debug        │
└───────┴───────────┴─────────┴────────────────┘
```

Options:

- `printConfig(result, { silent: true })` — returns the string without printing to console
- `printConfig(result, { maxValueLength: 30 })` — truncate long values (default: 50)

## Error Handling

When validation fails, config-loader throws a `ConfigLoadError` with structured error details:

```typescript
import c, { ConfigLoadError } from "@meltstudio/config-loader";

try {
  const config = c.schema({ port: c.number({ required: true }) }).load({
    env: false,
    args: false,
    files: "./config.yaml",
  });
} catch (err) {
  if (err instanceof ConfigLoadError) {
    for (const entry of err.errors) {
      console.error(`[${entry.kind}] ${entry.message}`);
      // e.g. [required] Required option 'port' not provided.
    }
  }
}
```

Warnings (non-fatal issues like type coercions) are never printed to the console. Use `loadExtended()` to access them, or they are included in `ConfigLoadError.warnings` when errors occur.

### Strict Mode

Enable `strict: true` to promote all warnings to errors, causing `ConfigLoadError` to be thrown for any ambiguous or lossy configuration:

```typescript
.load({
  env: true,
  args: false,
  files: "./config.yaml",
  strict: true,
})
```

This is useful in production environments where you want to catch type coercions, null values, and other ambiguous config early rather than silently accepting them.

## TypeScript Utilities

config-loader exports several types for advanced use cases:

```typescript
import c, {
  type SchemaValue, // Infer the resolved config type from a schema
  type SettingsSources, // Type for the sources object passed to load()
  type ExtendedResult, // Return type of loadExtended()
  type NodeTree, // Tree of ConfigNode objects (ExtendedResult.data)
  ConfigNode, // Class representing a resolved value with source metadata
  ConfigNodeArray, // Class representing an array of ConfigNode values
  type RecursivePartial, // Deep partial utility used by the defaults option
  type StandardSchemaV1, // Standard Schema v1 interface for validators
} from "@meltstudio/config-loader";
```

The most commonly needed is `SchemaValue`, which infers the plain TypeScript type from a schema:

```typescript
const mySchema = {
  port: c.number({ env: "PORT" }),
  db: c.object({ item: { host: c.string(), port: c.number() } }),
};

type MyConfig = SchemaValue<typeof mySchema>;
// { port: number; db: { host: string; port: number } }
```

## CLI Arguments

Set `cli: true` on an option to allow overriding via command line:

```typescript
c.schema({
  version: c.string({ required: true, cli: true }),
});
```

```bash
node app.js --version 2.0.0
```

## Environment Variables

Set `env: "VAR_NAME"` on an option and `env: true` in the load options:

```typescript
c.schema({
  database: c.object({
    item: {
      password: c.string({ env: "DB_PASSWORD" }),
    },
  }),
}).load({ env: true, args: false, files: "./config.yaml" });
```

## `.env` File Support

Load environment variables from `.env` files using the `envFile` option. Options with an `env` mapping automatically pick up values from `.env` files — no new syntax needed on individual fields.

**.env:**

```bash
DB_HOST=localhost
DB_PORT=5432
DB_PASSWORD="s3cret"
APP_NAME='My App'
# This is a comment
```

**Usage:**

```typescript
const config = c
  .schema({
    host: c.string({ env: "DB_HOST" }),
    port: c.number({ env: "DB_PORT" }),
    password: c.string({ env: "DB_PASSWORD" }),
  })
  .load({
    env: true,
    args: false,
    envFile: "./.env",
  });
```

`process.env` always takes precedence over `.env` file values. This means you can use `.env` files for development defaults while overriding them in production via real environment variables.

**Multiple `.env` files:**

```typescript
.load({
  env: true,
  args: false,
  envFile: ["./.env", "./.env.local"],  // .env.local overrides .env
})
```

When using multiple files, later files override earlier ones for the same key.

The `.env` parser supports:

- `KEY=VALUE` pairs (whitespace trimmed)
- Comments (lines starting with `#`)
- Quoted values (double `"..."` or single `'...'` quotes stripped)
- Empty values (`KEY=`)

When using `loadExtended()`, values from `.env` files have `sourceType: "envFile"` with `file`, `line`, and `column` metadata pointing to the `.env` file location.

## Common Patterns

### Load from YAML with env overrides

```typescript
import c from "@meltstudio/config-loader";

const config = c
  .schema({
    port: c.number({ required: true, env: "PORT", defaultValue: 3000 }),
    host: c.string({ required: true, env: "HOST", defaultValue: "localhost" }),
  })
  .load({ env: true, args: false, files: "./config.yaml" });
```

### Strict mode for production

```typescript
const config = c
  .schema({
    port: c.number({ required: true, env: "PORT" }),
    dbUrl: c.string({ required: true, env: "DATABASE_URL" }),
  })
  .load({
    env: true,
    args: false,
    files: "./config.yaml",
    strict: true, // any type coercion or ambiguity throws an error
  });
```

### Catch and inspect errors

```typescript
import c, { ConfigLoadError } from "@meltstudio/config-loader";

try {
  const config = c
    .schema({ port: c.number({ required: true }) })
    .load({ env: false, args: false, files: "./config.yaml" });
} catch (err) {
  if (err instanceof ConfigLoadError) {
    for (const entry of err.errors) {
      console.error(`[${entry.kind}] ${entry.path}: ${entry.message}`);
    }
    // err.warnings contains non-fatal issues
  }
}
```

### Load from a directory of config files

```typescript
const config = c
  .schema({
    port: c.number({ required: true }),
    host: c.string({ required: true }),
  })
  .load({ env: false, args: false, dir: "./config.d/" });
// All YAML/JSON files in the directory are loaded and merged (sorted by filename)
```

### Access source metadata with loadExtended

```typescript
const { data, warnings } = c
  .schema({
    port: c.number({ required: true, env: "PORT" }),
  })
  .loadExtended({ env: true, args: false, files: "./config.yaml" });

const portNode = data.port; // ConfigNode
console.log(portNode.value); // 3000
console.log(portNode.sourceType); // "env" | "file" | "default" | "args" | "envFile"
console.log(portNode.file); // "./config.yaml" or null
console.log(portNode.line); // source line number or null
```

### Combine .env files with process.env

```typescript
const config = c
  .schema({
    apiKey: c.string({ required: true, env: "API_KEY" }),
    debug: c.bool({ env: "DEBUG", defaultValue: false }),
  })
  .load({
    env: true, // reads process.env
    args: false,
    envFile: ["./.env", "./.env.local"], // .env.local overrides .env
  });
// Priority: process.env > .env.local > .env > defaults
```

## Common Mistakes

### Forgetting `item` in `c.object()`

```typescript
// WRONG — fields are passed directly
c.object({ host: c.string(), port: c.number() });

// CORRECT — fields must be inside `item`
c.object({ item: { host: c.string(), port: c.number() } });
```

### Setting `env` on an option but not enabling env loading

```typescript
// WRONG — env: "PORT" is set but env loading is disabled
c.schema({ port: c.number({ env: "PORT" }) }).load({
  env: false,
  args: false,
  files: "./config.yaml",
});
// This emits a warning: "Options [port] have env mappings but env loading is disabled"

// CORRECT — set env: true in load options
c.schema({ port: c.number({ env: "PORT" }) }).load({
  env: true,
  args: false,
  files: "./config.yaml",
});
```

### Expecting `.env` files to work without `envFile`

```typescript
// WRONG — .env files are not loaded by default
c.schema({ key: c.string({ env: "API_KEY" }) }).load({
  env: true,
  args: false,
});
// This only reads process.env, not .env files

// CORRECT — explicitly pass envFile
c.schema({ key: c.string({ env: "API_KEY" }) }).load({
  env: true,
  args: false,
  envFile: "./.env",
});
```

### Not catching `ConfigLoadError`

```typescript
// WRONG — unhandled error crashes the process with an unhelpful stack trace
const config = c
  .schema({ port: c.number({ required: true }) })
  .load({ env: false, args: false });

// CORRECT — catch and handle structured errors
try {
  const config = c
    .schema({ port: c.number({ required: true }) })
    .load({ env: false, args: false });
} catch (err) {
  if (err instanceof ConfigLoadError) {
    console.error(err.errors); // structured error details
  }
}
```

### Using `required: true` on nested fields without the parent object

If the parent object is entirely absent from all sources, child `required` fields will still trigger errors. Use `required` on the parent `c.object()` only if the entire subtree must be present.

## License

This package is licensed under the MIT License. See the [LICENSE](https://github.com/MeltStudio/config-loader/blob/main/LICENSE) file for details.
